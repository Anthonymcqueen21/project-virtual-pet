"use strict";(self.webpackChunktu_cis_4398_docs_template=self.webpackChunktu_cis_4398_docs_template||[]).push([[424],{3905:(e,n,t)=>{t.d(n,{Zo:()=>d,kt:()=>g});var a=t(7294);function r(e,n,t){return n in e?Object.defineProperty(e,n,{value:t,enumerable:!0,configurable:!0,writable:!0}):e[n]=t,e}function i(e,n){var t=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);n&&(a=a.filter((function(n){return Object.getOwnPropertyDescriptor(e,n).enumerable}))),t.push.apply(t,a)}return t}function s(e){for(var n=1;n<arguments.length;n++){var t=null!=arguments[n]?arguments[n]:{};n%2?i(Object(t),!0).forEach((function(n){r(e,n,t[n])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(t)):i(Object(t)).forEach((function(n){Object.defineProperty(e,n,Object.getOwnPropertyDescriptor(t,n))}))}return e}function o(e,n){if(null==e)return{};var t,a,r=function(e,n){if(null==e)return{};var t,a,r={},i=Object.keys(e);for(a=0;a<i.length;a++)t=i[a],n.indexOf(t)>=0||(r[t]=e[t]);return r}(e,n);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);for(a=0;a<i.length;a++)t=i[a],n.indexOf(t)>=0||Object.prototype.propertyIsEnumerable.call(e,t)&&(r[t]=e[t])}return r}var l=a.createContext({}),c=function(e){var n=a.useContext(l),t=n;return e&&(t="function"==typeof e?e(n):s(s({},n),e)),t},d=function(e){var n=c(e.components);return a.createElement(l.Provider,{value:n},e.children)},m="mdxType",u={inlineCode:"code",wrapper:function(e){var n=e.children;return a.createElement(a.Fragment,{},n)}},p=a.forwardRef((function(e,n){var t=e.components,r=e.mdxType,i=e.originalType,l=e.parentName,d=o(e,["components","mdxType","originalType","parentName"]),m=c(t),p=r,g=m["".concat(l,".").concat(p)]||m[p]||u[p]||i;return t?a.createElement(g,s(s({ref:n},d),{},{components:t})):a.createElement(g,s({ref:n},d))}));function g(e,n){var t=arguments,r=n&&n.mdxType;if("string"==typeof e||r){var i=t.length,s=new Array(i);s[0]=p;var o={};for(var l in n)hasOwnProperty.call(n,l)&&(o[l]=n[l]);o.originalType=e,o[m]="string"==typeof e?e:r,s[1]=o;for(var c=2;c<i;c++)s[c]=t[c];return a.createElement.apply(null,s)}return a.createElement.apply(null,t)}p.displayName="MDXCreateElement"},7286:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>l,contentTitle:()=>s,default:()=>m,frontMatter:()=>i,metadata:()=>o,toc:()=>c});var a=t(7462),r=(t(7294),t(3905));const i={sidebar_position:6},s="Database Diagrams",o={unversionedId:"system-architecture/database-diagrams",id:"system-architecture/database-diagrams",title:"Database Diagrams",description:"Entity-Relation Diagram",source:"@site/docs/system-architecture/database-diagrams.md",sourceDirName:"system-architecture",slug:"/system-architecture/database-diagrams",permalink:"/project-virtual-pet/docs/system-architecture/database-diagrams",draft:!1,editUrl:"https://github.com/Capstone-Projects-2023-Spring/project-virtual-pet/edit/main/documentation/docs/system-architecture/database-diagrams.md",tags:[],version:"current",lastUpdatedBy:"Alexander-Russakoff",sidebarPosition:6,frontMatter:{sidebar_position:6},sidebar:"docsSidebar",previous:{title:"Algorithms",permalink:"/project-virtual-pet/docs/system-architecture/algorithms"},next:{title:"API Specification",permalink:"/project-virtual-pet/docs/category/api-specification"}},l={},c=[{value:"Entity-Relation Diagram",id:"entity-relation-diagram",level:2}],d={toc:c};function m(e){let{components:n,...t}=e;return(0,r.kt)("wrapper",(0,a.Z)({},d,t,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("h1",{id:"database-diagrams"},"Database Diagrams"),(0,r.kt)("h2",{id:"entity-relation-diagram"},"Entity-Relation Diagram"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},'\nerDiagram\n\n    USER ||--|{ AVATAR : owns\n    USER ||--o{ INVENTORY : owns\n    USER ||--o{ TASK : owns\n    USER ||--|| USERMETA : owns\n    AVATAR }|--|| MOODSTORE : references\n    USER {\n        charfield username PK \n        string first_name\n        string last_name\n        string password_hash "PBKDF2 or similar"\n        string email\n        datetime last_login\n        datetime date_joined\n        int active_avatar FK "avatar_id from AVATAR table"        \n    }\n\n    AVATAR {\n        int avatar_id PK\n        charfield owner FK "USER - username"\n        charfield avatar_name \n        enum avatar_type FK  \n        int total_xp \n        datetime last_interaction\n        datetime last_feed\n        datetime birthday\n        string flavour_text "u for uropian"\n    }\n\n    INVENTORY {\n        int inventory_id PK\n        charfield username FK\n        enum candy_base_type "SMALL, MEDIUM, LARGE, CAKE"\n        enum candy_level "multiplier for basetype, BEGINNER,\n            NOVICE,INTERMEDIATE, ADVANCED, EXPERT"   \n        int quantity\n        \n    }\n\n    TASK {\n        int task_id PK\n        charfield username FK\n        datetime due_date "optional"\n        bool completed "default = False"\n        bool recurring "default = False"\n        int recurrence_time_delta "optional default = 0, required if recurring"\n        int completion_status "1-4"\n        charfield course "optional - link Canvas task with course"\n        textfield description "optional field giving notes about task"\n\n    }\n\n    USERMETA {\n\n        charfield username FK\n        datetime birthday "Optional: Can get a birthday notification and Pet State will go to GREAT"\n        textfield description "Optional: User can give a brief description of their goals for profile"\n\n    }\n\n    MOODSTORE {\n\n        charfield avatar_type PK\n        charfield moodpath_sad "filename in static store"\n        charfield moodpath_neutral "filename in static store"\n        charfield moodpath_happy "filename in static store"\n\n    }\n\n\n\n```\n\n    This diagram shows the individual tables and their relations in our SQLite data-base. The tables are as follows:\n\n    - USER the Django default user implementation \n    - AVATAR holds pet information and relate back to USER(many2one)\n    - TASK holds tasks specified by USER(many2one)\n    - INVENTORY holds inventory items currently held by USER(many2one)\n    - USERMETA holds additional optional information about USER(one2one)\n    - MOODSTORE relates animation frame palettes to AVATAR(one2many)\n\n## Django Class Diagram\n\n```mermaid\n---\ntitle: Brain Buddies API Class Diagram\n---\nclassDiagram\n\n\n\n\n    UserView <--\x3e UserSerializer\n    UserView <--\x3e UserMetaSerializer\n    UserMetaView <--\x3e UserMetaSerializer\n    AvatarView <--\x3e AvatarSerializer\n    InventoryView <--\x3e InventorySerializer\n    TaskView <--\x3e TaskSerializer\n\n    InitializerView o-- UserSerializer\n    InitializerView o-- AvatarSerializer\n    InitializerView o-- TaskSerializer\n    InitializerView o-- InventorySerializer\n    InitializerView o-- UserMetaSerializer\n\n    UserAvatarListView o-- UserSerializer\n    UserAvatarListView o-- AvatarSerializer\n\n    UserInventoryListView o-- UserSerializer\n    UserInventoryListView o-- InventorySerializer\n    \n    UserTaskListView o-- UserSerializer\n    UserTaskListView o-- TaskSerializer\n\n\n    class UserSerializer{\n        -String username\n        -String firstName\n        -String lastName\n        -string email\n        -datetime lastLogin\n        -datetime dateJoined\n\n\n        +getUserInfo(String username): JSON "username,firstName,lastName,email" \n        +getUserDateInfo(String username): JSON "lastLogin,dateJoined"\n    }\n    class AvatarSerializer{\n        -int avatarId\n        -String owner "match username from USER table"\n        -String avatarName\n        -String avatarType \n        -int totalXp\n        -datetime lastInteraction\n        -datetime lastFeed\n\n        +getAvatarList(String username): int[] "avatarId"\n        +getAvatarInfo(String username,int avatarId): JSON "avatarName,avatarType,totalXp,mood"\n        +getMood(String username,int avatarId): String "calculate mood based on last interaction and feeding and return as string"\n        \n    }\n    class TaskSerializer{\n        -int taskId\n        -String username\n        -datetime dueDate\n        -bool completed\n        -bool recurring\n        -int recurrenceTimeDelta\n        -String course\n        -String description\n\n        +getTaskList(String username):JSON[] "array task objects"\n        +getTask(int taskId)\n\n    }\n    class InventorySerializer{\n        -int inventoryId\n        -String candyBaseType \n        -int candyLevel\n        -int quantity\n\n        +getInventoryList(String username):JSON[] "array of inventory objects"\n        \n    }\n\n    class UserMetaSerializer{\n        -charfield username\n        -datetime birthday\n        -textfield description\n\n        +getUserMeta(String username):JSON "usermeta object"\n    }\n\n    class UserView{\n\n        +createUser(JSON userObject)\n        +update(JSON userObject) \n        +delete(String username) "cascades to destroy all related data"\n    }\n    class AvatarView{\n        \n        +create(String username, JSON avatarObject)\n        +update(JSON avatarObject)\n        +delete(int avatarId)\n    }\n    class InventoryView{\n        +create(String username, JSON inventoryObject) "can fail if attempt to create inventory slot for same base and level"\n        +update(JSON inventoryObject)\n        +destroy(int inventoryId)\n    }\n    class TaskView{\n        +create(String username, JSON taskObject)\n        +update(JSON taskObject)\n        +destroy(int taskId)\n    }\n    class UserMetaView{\n        +create(String username, JSON userMetaObject)\n        +update(JSON oldMetaObject, JSON newMetaObject) \n        -destroy(String username) "private because cascade will destroy automatically"\n    }\n    class InitializerView{\n        \n        +getUserFullDescription(String username): JSON[] "returns deeply nested array containing all information needed to render home page"\n    }\n\n    class UserAvatarListView{\n\n        +getAvatarList(String username): JSON[] \n\n    }\n    class UserInventoryListView{\n        +getUserInventoryList(String username): JSON[]\n        \n\n    }\n    class UserTaskListView{\n        +getUserTaskList(String username): JSON[]\n    }\n\n\n```\n\n\n\n    This class diagram shows the relations between serializer and view classes in our Django backend. Each serializer acts as an adapter for the tables in our database. The view classes represent the functionality of each URL endpoint that will be specified in our API.\n')))}m.isMDXComponent=!0}}]);